var documenterSearchIndex = {"docs":
[{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"CurrentModule = VlasovPoissonTwoSpecies","category":"page"},{"location":"scheme/#Numerical-scheme","page":"Numerical method","title":"Numerical scheme","text":"","category":"section"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"This type contains data for the numerical scheme ","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"f^pm(txv) = f_0^pm(xv) + g^pm(txv)","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"where f_0^pm(xv) a stationary solution ","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"T_phi = v partial_x - partial_x phi partial_v","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"this term is computed in T_f","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"beginaligned\n    partial_t g^+ +  T_phi_f g^+  = partial_x phi_g partial_v f_0^+\n        partial_t g^- +  mu T_- phi_f g^- = -partial_x phi_g partial_v f_0^-\n  endaligned","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"where phi_g = phi_f- phi_f_0 is the potential associated with g. The two potentials satisfy the following equations","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"    partial_xx phi_f = int_mathbbR(f^- - f^+) dv quad partial_xx phi_g = int_mathbbR(g^- - g^+) dv","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"and the initial condition for g^pm is given by","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"  beginaligned\n    g^+(0xv) = f_in^+(xv) - f_0^+(xv) quad     g^-(0xv) = f_in^-(xv) - f_0^-(xv)\n  endaligned","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"We use a time splitting scheme where the term pmpartial_x phi_g partial_v f_0^pm is treated as a source term with three main steps (with mu=1)","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"  beginaligned\n    (1) quad partial_t g^pm = pm partial_x phi_g partial_v f_0^pm\n    (2) quad partial_t g^pm + v partial_x g^pm = 0\n    (3) quad partial_t g^pm mp partial_x phi_fpartial_v g^pm = 0\n  endaligned","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"We consider a second order in time discretization to solve (2) and (3) from t^n to t^n+1. In the following Delta t denotes the time step, g^n the semi-discretization in time of the unknown g at t^n = n Delta t and g^(k) intermediate steps between t^n and t^n+1. For simplicity we drop the index pm but it is important to note that the steps of the procedure described below are computed at the same time for g^+ and g^-. This is require to solve the Poisson equation when evaluating partial_x phi_g. One obtains the following algorithm","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"Solve step (1) over a half time step with compute_source: g^(1) = g^n + fracDelta t2 partial_x phi_g^n partial_v f_0 where partial_xphi_g^n is calculated with Poisson equation,\nSolve step (2) over a half time step: g^(2)(xv) = g^(1)(x-vfracDelta t2 v), with advect.\nUpdate the value of E^(2) = -partial_x phi_f^(2) with Poisson solver and f^(2) = f_0 + g^(2), with compute_rho and compute_e.\nSolve step (3) over a whole time step: g^(3)(xv) = g^(2)(xv-E^(2) Delta t)\nSolve step (2) over a half time step: g^(4)(xv) = g^3(x-vfracDelta t2v)\nSolve step (1) over a half time step: g^(5) = g^(4) + fracDelta t2 partial_x phi_g^(4) partial_v f_0 where partial_xphi_g^(4) is calculated with Poisson solver.","category":"page"},{"location":"scheme/","page":"Numerical method","title":"Numerical method","text":"\n# step 1\ncompute_source(scheme, 0.5dt)\n\n# step 2\nadvect(scheme.advection_x, scheme.ge, v, 0.5dt)\nadvect(scheme.advection_x, scheme.gi, v, 0.5dt)\n\nrho .= compute_rho(scheme)\ne .= compute_e(mesh_x, rho)\ne .+= scheme.e_eq\n\n# step 3\nadvect(scheme.advection_v, transpose(scheme.ge), -e, dt)\nadvect(scheme.advection_v, transpose(scheme.gi), e, dt)\n\n# step 2\nadvect(scheme.advection_x, scheme.ge, v, 0.5dt)\nadvect(scheme.advection_x, scheme.gi, v, 0.5dt)\n\n# step 1\ncompute_source(scheme, 0.5dt)\n\nscheme.fe .= scheme.fe_eq .+ scheme.ge\nscheme.fi .= scheme.fi_eq .+ scheme.gi\n\n","category":"page"},{"location":"simu/","page":"Simulation","title":"Simulation","text":"CurrentModule = VlasovPoissonTwoSpecies","category":"page"},{"location":"simu/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simu/","page":"Simulation","title":"Simulation","text":"using Plots\nusing VlasovPoissonTwoSpecies\nimport SpecialFunctions: ellipk","category":"page"},{"location":"simu/","page":"Simulation","title":"Simulation","text":"function run(coef, data)\n    \n     mesh_x = Mesh(data.x_min, data.x_max, data.nx)\n     mesh_v = Mesh(data.v_min, data.v_max, data.nv)\n      \n     x = mesh_x.x\n     v = mesh_v.x\n\n     tf = data.T_final\n     nt = data.nb_time_steps\n     dt = tf / nt\n     \n     eq_manager = EquilibriumManager(coef, mesh_x, mesh_v)\n     output = OutputManager(data, eq_manager)\n     \n     fe = perturbate(x, v, eq_manager.fe, data.perturbation_init)\n     fi = perturbate(x, v, eq_manager.fi, data.perturbation_init)\n     \n     scheme = WellBalanced( fe, fi, eq_manager)\n\n     rho = zeros(mesh_x.nx)\n     e = zeros(mesh_x.nx)\n     \n     for it = 1:nt\n     \n         if it % data.freq_save == 0\n             if data.output\n                 save(output, scheme, it * dt)\n             end\n         end\n\n         compute_source(scheme, 0.5dt)\n\n         advect(scheme.advection_x, scheme.ge, v, 0.5dt)\n         advect(scheme.advection_x, scheme.gi, v, 0.5dt)\n\n         rho .= compute_rho(scheme)\n         e .= compute_e(mesh_x, rho)\n\n         e .+= scheme.e_eq\n\n         advect(scheme.advection_v, transpose(scheme.ge), -e, dt)\n         advect(scheme.advection_v, transpose(scheme.gi), e, dt)\n\n         advect(scheme.advection_x, scheme.ge, v, 0.5dt)\n         advect(scheme.advection_x, scheme.gi, v, 0.5dt)\n\n         scheme.fe .= scheme.fe_eq .+ scheme.ge\n         scheme.fi .= scheme.fi_eq .+ scheme.gi\n\n         compute_source(scheme, 0.5dt)\n\n     end\n     \n     output\n\nend","category":"page"},{"location":"simu/","page":"Simulation","title":"Simulation","text":"\nrefine_dt              = 1\nrefine_factor          = 1\neps_perturbation       = 0.001\n\ncoef = Coef()\n\ndata                   = Data()\ndata.projection        = false\ndata.projection_type   = :coefficients   # :BGK\ndata.T_final           = 200\ndata.nb_time_steps     = 1000 * refine_factor * refine_dt\ndata.nx                = 64 * refine_factor\ndata.nv                = 64 * refine_factor\ndata.x_min             = 0\ndata.x_max             = 4 * ellipk(coef.m)\ndata.v_min             = -10\ndata.v_max             = 10\ndata.perturbation_init = (x, v) -> eps_perturbation * (cos(2π * x / (data.x_max - data.x_min) + 1))\ndata.output            = true\ndata.vtk               = true\ndata.freq_save         = 5 * refine_factor * refine_dt\ndata.freq_output       = 5 * refine_factor * refine_dt\ndata.freq_projection   = 5 * 5 * refine_factor * refine_dt\n\n@time output = run(coef, data)","category":"page"},{"location":"simu/","page":"Simulation","title":"Simulation","text":"plot(output.t, output.energy_fe, label=\"electrons\")\nplot!(output.t, output.energy_fi, label=\"ions\", legend=:topleft)","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [VlasovPoissonTwoSpecies]","category":"page"},{"location":"api/#VlasovPoissonTwoSpecies.Advection","page":"API","title":"VlasovPoissonTwoSpecies.Advection","text":"struct Advection\n\nAdvection to be computed on each row\n\nmesh::Mesh\np::Int64\nmodes::Vector{Float64}\neig_bspl::Vector{Float64}\neigalpha::Vector{ComplexF64}\n\n\n\n\n\n","category":"type"},{"location":"api/#VlasovPoissonTwoSpecies.Coef","page":"API","title":"VlasovPoissonTwoSpecies.Coef","text":"mutable struct Coef\n\nUse this type to set the coefficients for the equation\n\nBig(fracddx yBig)^2 = alpha y^4 + gamma y^2 + epsilon\n\nThree sets of coefficients are availabe:\n\n:JacobiDN\n:JacobiND\n:JacobiCN\n\n\n\n\n\n","category":"type"},{"location":"api/#VlasovPoissonTwoSpecies.EquilibriumManager","page":"API","title":"VlasovPoissonTwoSpecies.EquilibriumManager","text":"struct EquilibriumManager\n\nmesh_x::Mesh\nmesh_v::Mesh\ncoef::Coef\nfe::Matrix{Float64}\nfi::Matrix{Float64}\ndx_fe::Matrix{Float64}\ndv_fe::Matrix{Float64}\ndx_fi::Matrix{Float64}\ndv_fi::Matrix{Float64}\n\nStationary solutions to Vlasov-Poisson under the following form\n\n  begincases\n    f^+(xv) = sqrtfracapiBig(r_1 e^2 a (fracv^22+phi(x)) + fracr_2sqrt2  e^a(fracv^22+phi(x))Big)\n        f^-(xv) = sqrtfracamu piBig(s_1 e^2 a (fracv^22 mu-phi(x)) + fracs_2sqrt2 e^a(fracv^22 mu-phi(x))Big)\nendcases\n\n\n\n\n\n","category":"type"},{"location":"api/#VlasovPoissonTwoSpecies.OutputManager","page":"API","title":"VlasovPoissonTwoSpecies.OutputManager","text":"struct OutputManager\n\ndata::Data\nmesh_x::Mesh\nmesh_v::Mesh\nnb_outputs::Int64\nt::Vector{Float64}\ncompute_energy_eq::Bool\nenergy_fe_init::Float64\nenergy_fi_init::Float64\nenergy_fe::Vector{Float64}\nenergy_fi::Vector{Float64}\n\nData structure to manage outputs.\n\n\n\n\n\n","category":"type"},{"location":"api/#VlasovPoissonTwoSpecies.Scheme","page":"API","title":"VlasovPoissonTwoSpecies.Scheme","text":"struct Scheme\n\nmesh_x::Mesh\nmesh_v::Mesh\nadvection_x::VlasovPoissonTwoSpecies.Advection\nadvection_v::VlasovPoissonTwoSpecies.Advection\nfe::Matrix{Float64}\nfi::Matrix{Float64}\nge::Matrix{Float64}\ngi::Matrix{Float64}\nρ_eq::Vector{Float64}\ne_eq::Vector{Float64}\nfe_eq::Matrix{Float64}\nfi_eq::Matrix{Float64}\ndx_fe_eq::Matrix{Float64}\ndx_fi_eq::Matrix{Float64}\ndv_fe_eq::Matrix{Float64}\ndv_fi_eq::Matrix{Float64}\nwb_scheme::Bool\ne_projection::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#VlasovPoissonTwoSpecies.WellBalanced","page":"API","title":"VlasovPoissonTwoSpecies.WellBalanced","text":"struct WellBalanced <: VlasovPoissonTwoSpecies.AbstractScheme\n\nmesh_x::Mesh\nmesh_v::Mesh\nadvection_x::VlasovPoissonTwoSpecies.Advection\nadvection_v::VlasovPoissonTwoSpecies.Advection\nfe::Matrix{Float64}\nfi::Matrix{Float64}\nge::Matrix{Float64}\ngi::Matrix{Float64}\ngeᵗ::Matrix{Float64}\ngiᵗ::Matrix{Float64}\nρ_eq::Vector{Float64}\ne_eq::Vector{Float64}\nfe_eq::Matrix{Float64}\nfi_eq::Matrix{Float64}\ndx_fe_eq::Matrix{Float64}\ndx_fi_eq::Matrix{Float64}\ndv_fe_eq::Matrix{Float64}\ndv_fi_eq::Matrix{Float64}\nt_f::Matrix{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#VlasovPoissonTwoSpecies.T_f","page":"API","title":"VlasovPoissonTwoSpecies.T_f","text":"T_f(mesh_x, mesh_v, f, e, dx_f, dv_f)\nT_f(mesh_x, mesh_v, f, e, dx_f, dv_f, order)\n\n\nT_phi = v partial_x - partial_x phi partial_v\n\n\n\n\n\n","category":"function"},{"location":"api/#VlasovPoissonTwoSpecies.advect-Tuple{VlasovPoissonTwoSpecies.Advection, Any, Any, Any}","page":"API","title":"VlasovPoissonTwoSpecies.advect","text":"advect(self, f, v, dt)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.advect_vlasov","page":"API","title":"VlasovPoissonTwoSpecies.advect_vlasov","text":"advect_vlasov(advection_x, advection_v, fe, fi, dt)\nadvect_vlasov(advection_x, advection_v, fe, fi, dt, e_eq)\nadvect_vlasov(\n    advection_x,\n    advection_v,\n    fe,\n    fi,\n    dt,\n    e_eq,\n    order\n)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#VlasovPoissonTwoSpecies.bspline-Tuple{Int64, Int64, Float64}","page":"API","title":"VlasovPoissonTwoSpecies.bspline","text":"bspline(p, j, x)\n\n\nReturn the value at x in [0,1] of the B-spline with integer nodes of degree p with support starting at j.  Implemented recursively using the  De Boor's Algorithm\n\nB_i0(x) = left\nbeginmatrix\n1  mathrmif  quad t_i  x  t_i+1 \n0  mathrmotherwise \nendmatrix\nright\n\nB_ip(x) = fracx - t_it_i+p - t_i B_ip-1(x) \n+ fract_i+p+1 - xt_i+p+1 - t_i+1 B_i+1p-1(x)\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.compute_e-Tuple{Mesh, Vector{Float64}}","page":"API","title":"VlasovPoissonTwoSpecies.compute_e","text":"compute_e(mesh_x, rho)\n\n\ncompute Ex using that \n\n-ikE_x = rho \n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.compute_energy-Tuple{Any, Any, Any}","page":"API","title":"VlasovPoissonTwoSpecies.compute_energy","text":"compute_energy(mesh_x, mesh_v, f)\n\n\ne_f = int v^2 f dv\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.compute_normalized_energy-Tuple{Any, Any, Any}","page":"API","title":"VlasovPoissonTwoSpecies.compute_normalized_energy","text":"compute_normalized_energy(self, fe, fi)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.compute_rho-Tuple{Mesh, Matrix{Float64}}","page":"API","title":"VlasovPoissonTwoSpecies.compute_rho","text":"compute_rho(meshv, f)\n\n\nCompute charge density\n\nrho(xt) = int f(xvt) dv\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.compute_source-Tuple{WellBalanced, Any}","page":"API","title":"VlasovPoissonTwoSpecies.compute_source","text":"compute_source(scheme, dt)\n\n\npartial_t g^pm = pm partial_x phi_g partial_v f_0^pm\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.get_normalized_energy-NTuple{4, Any}","page":"API","title":"VlasovPoissonTwoSpecies.get_normalized_energy","text":"get_normalized_energy(mesh_x, mesh_v, f, energy_eq)\n\n\nreturns the normalized energy \n\ne_f - e_eq  e_eq\n\nwhere e_f is the energy of f.\n\n\n\n\n\n","category":"method"},{"location":"api/#VlasovPoissonTwoSpecies.landau-NTuple{4, Any}","page":"API","title":"VlasovPoissonTwoSpecies.landau","text":"landau(ϵ, k, meshx, meshv)\n\n\nLandau Damping\n\nf(xv) = frac1sqrt2pi(1 + epsilon cos ( k x )) exp (- fracv^22 )\n\nLandau damping - Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VlasovPoissonTwoSpecies","category":"page"},{"location":"#Vlasov-Poisson-system","page":"Home","title":"Vlasov-Poisson system","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The system considered is the two species Vlasov-Poisson system which is a simple model used to describe a collisionless plasma.","category":"page"},{"location":"","page":"Home","title":"Home","text":"  begincases\n    partial_t f^+ + v partial_xf^+ - partial_x phi partial_v f^+ = 0\n    partial_t f^- + v partial_xf^- + mu partial_x phi partial_v f^- = 0\n  endcases","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the potential phi = phi(x) satisfy","category":"page"},{"location":"","page":"Home","title":"Home","text":"   partial_xx phi = int_mathbbR(f^- - f^+) dv","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mu  0 is the mass ratio, f^+ = f^+(txv) and f^- = f^-(txv) denote the distribution function for the ions and electrons respectively. The system is given with an initial condition","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation*\n  begincases\n    f^+(0xv) = f_in^+(xv)\n        f^-(0xv) = f_in^-(xv)\n  endcases\nendequation*","category":"page"},{"location":"","page":"Home","title":"Home","text":"on the domain x in 0 L, v in mathbbR where we assume periodic boundary conditions in x and vanishing boundary conditions in v.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The well-balanced numerical scheme is using a micro-macro type decomposition, where the macro part corresponds to the equilibrium and the micro part corresponds to the out of equilibrium part.  The numerical solution will be written as f^pm = f_0 ^pm + g^pm where f_0^pm  is a given equilibrium and g^pm can be seen as a perturbation of f_0^pm The unknown of the reformulated problem will be the perturbation g^pm","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute the initial solution, you can use the Coef type: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nusing VlasovPoissonTwoSpecies\n\ncoef = Coef()\n\nx_min, x_max, nx = 0., 1., 64\nv_min, v_max, nv = -10., 10, 64\n\nmesh_x = Mesh(x_min, x_max, nx)\nmesh_v = Mesh(v_min, v_max, nv)\n\nx = mesh_x.x\nv = mesh_v.x\n\neq = EquilibriumManager(coef, mesh_x, mesh_v)\n\np = plot(layout=(2), xlabel=\"x\", ylabel=\"v\")\ncontourf!(p[1], x, v, eq.fe, title=\"fe\")\ncontourf!(p[2], x, v, eq.fi, title=\"fi\")\n","category":"page"}]
}
